// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "ProxyServer.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <string>
#include <curl/curl.h>
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::RPC;

/////////////////////////////////////////////////////////////////////
//       complementary structures,functions,classes                // 
/////////////////////////////////////////////////////////////////////

struct wd_in {
  size_t size;
  size_t len;
  char *data;
};

size_t write_data(void *buffer, size_t size, 
		  size_t nmemb, void *userp) {
  struct wd_in *wdi = (struct wd_in *)userp;

  while(wdi->len + (size * nmemb) >= wdi->size) {
    /* check for realloc failing in real code. */
    wdi->data = (char*)realloc(wdi->data, wdi->size*2);
    wdi->size*=2;
  }

  memcpy(wdi->data + wdi->len, buffer, size * nmemb);
  wdi->len+=size*nmemb;

  return size * nmemb;
}




/////////////////////////////////////////////////////////////////////
//                   Proxy Server Handler                          // 
/////////////////////////////////////////////////////////////////////
class ProxyServerHandler : virtual public ProxyServerIf {
 public:
  ProxyServerHandler() {
    // Your initialization goes here
  }

  void getPage(std::string& _return, const std::string& url) {
    
    CURL *curl;
    CURLcode res;
    struct wd_in wdi;
    
    memset(&wdi, 0, sizeof(wdi));
    curl = curl_easy_init();
    
    if(NULL != curl) {
      wdi.size = 1024;
      wdi.data = (char*)malloc(wdi.size);
      curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
      curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
      curl_easy_setopt(curl, CURLOPT_WRITEDATA, &wdi);
      res = curl_easy_perform(curl);

      /* Check the return value. */
      if(res != CURLE_OK) _return = std::string("error");
      else _return = std::string(wdi.data, wdi.len);
      
      curl_easy_cleanup(curl);
    }
    else {
      fprintf(stderr, "Error: could not get CURL handle.\n");
      exit(EXIT_FAILURE);
    }

    free(wdi.data);
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<ProxyServerHandler> handler(new ProxyServerHandler());
  shared_ptr<TProcessor> processor(new ProxyServerProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

